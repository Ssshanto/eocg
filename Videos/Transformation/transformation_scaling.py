# -*- coding: utf-8 -*-
"""Transformation_Scaling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15yrkL__Ix1n9-6WNVARaYbT-RPgMkh33
"""

!sudo apt update
!sudo apt install libcairo2-dev ffmpeg \
    texlive texlive-latex-extra texlive-fonts-extra \
    texlive-latex-recommended texlive-science \
    tipa libpango1.0-dev
!pip install manim
!pip install IPython --upgrade

from manim import *

# Commented out IPython magic to ensure Python compatibility.
# %%manim -p Transform
# from manim import *
# 
# class Casper(VGroup):
#     def __init__(self):
#         super().__init__()
#         circle1 = Circle(color=BLUE, fill_opacity=.95)
#         circle2= Circle(color=WHITE, fill_opacity=1)
#         circle3= Circle(color=WHITE, fill_opacity=1)
#         square = Square()
#         triangle = Triangle(color=LIGHT_BROWN, fill_opacity=1)
#         triangle2 = Triangle()
#         
#         circle1.width=2
#         circle1.thickness=3
# 
#         circle2.scale(0.2)
#         circle2.set_stroke( width=1.25)
#         circle2.shift(LEFT* .5)
# 
#         
#         circle3.scale(0.2)
#         circle3.set_stroke( width=1.25)
#         circle3.shift(RIGHT* .5)
# 
#         circle4 = Circle(color=BLACK, fill_opacity=.75)
#         circle4.scale(0.155)
#         circle4.set_stroke( width=1.25)
#         circle4.shift(LEFT* .55)
# 
#         circle5=Circle(color=BLACK, fill_opacity=.75)
#         circle5.scale(0.155)
#         circle5.set_stroke( width=1.25)
#         circle5.shift(RIGHT* .45)
#         
#         square.shift(DOWN *1.75)
#         square.scale(.75)
# 
#         triangle.shift(UP *.65, RIGHT *.42)
#         triangle.scale(.95)
#         triangle.rotate(1.5)
#         triangle.border=2
# 
#         triangle2.shift( DOWN* 2)
#         triangle2.rotate(PI)
#         triangle2.scale(.45)
# 
#         smile = Arc(angle=.75*PI, radius=.2)    
#         smile.rotate(1.15*PI)
#         smile.shift(DOWN * .65)   
# 
#         
#         a = [2, 0, 0]
#         b = [0, 1.75, 0]
#         c = [0, 0, 1.75]
#         
#         ap1 = ArcPolygon(a, b, c, radius=2, color=BLUE, fill_opacity=.75)
#         
#         ap_group = VGroup(ap1).arrange()
#         ap_group.shift(DOWN * 1.75)
#         ap_group.rotate( 1.65* PI * .75)
# 
#         self.add(ap_group, triangle2, circle1, circle2, circle3, circle4, circle5, triangle, smile)
# 
# class Transform(Scene):
#     def construct(self):
#       c=Casper()
#       text=Text("Transformation", font_size=40)
#       self.play(text.animate.to_edge(UP))
#       text2=Text("Scaling", font_size=25)
#       self.play(text2.animate.shift(UP*2.5))
#       c.scale(.45)
#       c.shift(ORIGIN)
#       self.play(Create(c))
#       self.play(c.animate.scale(2))
#       text3=Text("But how does it work?",font_size=20, color=BLUE)
#       box = SurroundingRectangle(text3, color=YELLOW, buff=MED_LARGE_BUFF)
#       group=VGroup(box,text3)
#       group.shift(DOWN*3)
#       self.play(Create(group), run_time=3)
# 
# 
# 
#       self.wait(3)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -p Transform2
# from manim import *
# 
# class Casper(VGroup):
#     def __init__(self):
#         super().__init__()
#         circle1 = Circle(color=BLUE, fill_opacity=.95)
#         circle2= Circle(color=WHITE, fill_opacity=1)
#         circle3= Circle(color=WHITE, fill_opacity=1)
#         square = Square()
#         triangle = Triangle(color=LIGHT_BROWN, fill_opacity=1)
#         triangle2 = Triangle()
#         
#         circle1.width=2
#         circle1.thickness=3
# 
#         circle2.scale(0.2)
#         circle2.set_stroke( width=1.25)
#         circle2.shift(LEFT* .5)
# 
#         
#         circle3.scale(0.2)
#         circle3.set_stroke( width=1.25)
#         circle3.shift(RIGHT* .5)
# 
#         circle4 = Circle(color=BLACK, fill_opacity=.75)
#         circle4.scale(0.155)
#         circle4.set_stroke( width=1.25)
#         circle4.shift(LEFT* .55)
# 
#         circle5=Circle(color=BLACK, fill_opacity=.75)
#         circle5.scale(0.155)
#         circle5.set_stroke( width=1.25)
#         circle5.shift(RIGHT* .45)
#         
#         square.shift(DOWN *1.75)
#         square.scale(.75)
# 
#         triangle.shift(UP *.65, RIGHT *.42)
#         triangle.scale(.95)
#         triangle.rotate(1.5)
#         triangle.border=2
# 
#         triangle2.shift( DOWN* 2)
#         triangle2.rotate(PI)
#         triangle2.scale(.45)
# 
#         smile = Arc(angle=.75*PI, radius=.2)    
#         smile.rotate(1.15*PI)
#         smile.shift(DOWN * .65)   
# 
#         
#         a = [2, 0, 0]
#         b = [0, 1.75, 0]
#         c = [0, 0, 1.75]
#         
#         ap1 = ArcPolygon(a, b, c, radius=2, color=BLUE, fill_opacity=.75)
#         
#         ap_group = VGroup(ap1).arrange()
#         ap_group.shift(DOWN * 1.75)
#         ap_group.rotate( 1.65* PI * .75)
# 
#         self.add(ap_group, triangle2, circle1, circle2, circle3, circle4, circle5, triangle, smile)
# 
# class Transform2(Scene):
#     def construct(self):
#       c=Casper()
#       text=Text("Transformation", font_size=40)
#       self.play(text.animate.to_edge(UP))
#       text2=Text("Scaling", font_size=25, color=BLUE)
#       self.play(text2.animate.shift(UP*2.5))
#       c.scale(.45)
#       c.shift(ORIGIN)
#       self.play(Create(c))
#       self.play(c.animate.scale(2))
#       text3=Text("But how does it work?",font_size=20, color=WHITE)
#       box = BackgroundRectangle(text3, color=BLACK, buff=MED_LARGE_BUFF)
#       group=VGroup(box,text3)
#       group.shift(DOWN*3)
#       self.play(Create(group), run_time=3)
#       self.wait(2)
# 
#       number_plane = NumberPlane(
#             background_line_style={
#                 "stroke_color": TEAL,
#                 "stroke_width": 4,
#                 "stroke_opacity": 0.6
#             }
#         ).add_coordinates()
#       self.remove(text,text2)
#       self.wait(2)
#       self.play(group.animate.to_edge(UP))
#       self.wait(2)
#       self.play(Uncreate(c))
#       self.wait(2)
#       self.play(Create(number_plane), run_time=4)
#       self.wait(2)
#       cp=Casper()
#       cp.scale(.45)
#       cp.shift(ORIGIN)
#       self.play(Create(cp))
#       self.wait(3)
#       self.play(number_plane.animate.scale(.75))
#       self.wait(2)
#       text4=Text("For every transformation\nThe coordinate system updates itself according to your scaling!",font_size=20, color=WHITE)
#       box2 = BackgroundRectangle(text4, color=BLACK, buff=MED_LARGE_BUFF)
#       group2=VGroup(box2,text4)
#       group2.shift(DOWN*3)
#       self.play(Create(group2), run_time=4)
#       self.wait(3)
#       self.remove(group2,c,number_plane,cp,text3)
#       self.wait(2)
#       cpp=Casper()
#       cpp.scale(.45)
#       cpp.shift(ORIGIN)
#       self.play(Create(cpp))
#       self.play(cpp.animate.to_edge(UP), run_time=3)
#       self.play(cpp.animate.to_edge(RIGHT), run_time=3)
#       st=Text("Old Coordinate: x, y", font_size=20)
#       st.shift(UP*2, LEFT*3)
#       self.play(Write(st))
#       st2=Text("New Coordinate: x', y'", font_size=20)
#       st2.shift(UP*1, LEFT*3)
#       self.play(Write(st2))
#       st3=Text("In That Case:\nx'= Scaling * x y'=Scaling * y", font_size=20)
#       box3 = SurroundingRectangle(st3, color=YELLOW, buff=MED_LARGE_BUFF)
#       group3=VGroup(box3,st3)
#       group3.shift(np.array([-3,-1,0]))
#       self.play(Create(group3), run_time=4)
#       self.wait(2)
#       self.remove(st,st2)
#       self.wait(2)
#       self.play(group3.animate.to_edge(UP))
#       var = 0.5
#       on_screen_var = Variable(var, Text("Scale X"), num_decimal_places=3)
# 
#       # You can also change the colours for the label and value
#       on_screen_var.label.set_color(RED)
#       on_screen_var.value.set_color(GREEN)
#       on_screen_var.scale(.75)
#       on_screen_var.shift(np.array([-1,-1,0]))
# 
#       self.play(Write(on_screen_var))
#       # The above line will just display the variable with
#       # its initial value on the screen. If you also wish to
#       # update it, you can do so by accessing the `tracker` attribute
#       self.wait()
#       var_tracker1 = on_screen_var.tracker
#       var = 5
#       #self.play(var_tracker1.animate.set_value(var))
#       self.wait()
# 
#       int_var = .5
#       on_screen_int_var = Variable(
#           int_var, Text("Scale Y"), num_decimal_places=3
#       ).next_to(on_screen_var, DOWN)
#       on_screen_int_var.label.set_color(RED)
#       on_screen_int_var.value.set_color(GREEN)
#       on_screen_int_var.scale(.75)
#       on_screen_int_var.shift(np.array([0,-.25,0]))
# 
#       self.play(Write(on_screen_int_var))
#       self.wait(2)
#       var_tracker = on_screen_int_var.tracker
#       var = 5
#       cpp.shift(LEFT*1, DOWN*1)
#       self.wait(2)
#       self.play(var_tracker.animate.set_value(var),var_tracker1.animate.set_value(var), cpp.animate.scale(2))
#       self.wait(3)
#       self.remove(on_screen_int_var,on_screen_var)
#       self.wait(2)
#       text5=Text("Matrix Representation: ", font_size=25)
#       text5.shift(np.array([-2,.5,0]))
#       self.play(Write(text5))
#       self.wait(2)
#       m0 = Matrix([['X'], ['Y']])
#       m1 = Matrix([['x'], ['y']])
#       m2 = Matrix([['Sx', 0], [0, 'Sy']])
# 
#       matrixg = Group(
#             m1,m2
#         ).arrange_in_grid(buff=0.5)
#       matrixg.shift(np.array([-2,-1,0]))
#       matrixg.scale(.75)
#       m0.scale(.75)
#       m0.shift(np.array([0.5,-1,0]))
#       self.add(matrixg)
#       self.wait(2)
#       self.add(m0)
#       text6=Text("Multiplying the first two matrix will result into the\nthird matrix which is your resultant!", font_size=20, color=BLUE)
#       box6 = SurroundingRectangle(text6, color=YELLOW, buff=MED_LARGE_BUFF)
#       gpx=VGroup(box6,text6)
#       gpx.shift(np.array([-2,-3,0]))
#       self.play(Write(gpx), run_time=4)
# 
# 
# 
#     
# 
# 
# 
#       self.wait(3)
# 
# 
#       
# 
# 
# 
#       self.wait(3)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -p Transform3
# from manim import *
# 
# class Casper(VGroup):
#     def __init__(self):
#         super().__init__()
#         circle1 = Circle(color=BLUE, fill_opacity=.95)
#         circle2= Circle(color=WHITE, fill_opacity=1)
#         circle3= Circle(color=WHITE, fill_opacity=1)
#         square = Square()
#         triangle = Triangle(color=LIGHT_BROWN, fill_opacity=1)
#         triangle2 = Triangle()
#         
#         circle1.width=2
#         circle1.thickness=3
# 
#         circle2.scale(0.2)
#         circle2.set_stroke( width=1.25)
#         circle2.shift(LEFT* .5)
# 
#         
#         circle3.scale(0.2)
#         circle3.set_stroke( width=1.25)
#         circle3.shift(RIGHT* .5)
# 
#         circle4 = Circle(color=BLACK, fill_opacity=.75)
#         circle4.scale(0.155)
#         circle4.set_stroke( width=1.25)
#         circle4.shift(LEFT* .55)
# 
#         circle5=Circle(color=BLACK, fill_opacity=.75)
#         circle5.scale(0.155)
#         circle5.set_stroke( width=1.25)
#         circle5.shift(RIGHT* .45)
#         
#         square.shift(DOWN *1.75)
#         square.scale(.75)
# 
#         triangle.shift(UP *.65, RIGHT *.42)
#         triangle.scale(.95)
#         triangle.rotate(1.5)
#         triangle.border=2
# 
#         triangle2.shift( DOWN* 2)
#         triangle2.rotate(PI)
#         triangle2.scale(.45)
# 
#         smile = Arc(angle=.75*PI, radius=.2)    
#         smile.rotate(1.15*PI)
#         smile.shift(DOWN * .65)   
# 
#         
#         a = [2, 0, 0]
#         b = [0, 1.75, 0]
#         c = [0, 0, 1.75]
#         
#         ap1 = ArcPolygon(a, b, c, radius=2, color=BLUE, fill_opacity=.75)
#         
#         ap_group = VGroup(ap1).arrange()
#         ap_group.shift(DOWN * 1.75)
#         ap_group.rotate( 1.65* PI * .75)
# 
#         self.add(ap_group, triangle2, circle1, circle2, circle3, circle4, circle5, triangle, smile)
# 
# class Transform3(Scene):
#     def construct(self):
#       cpp=Casper()
#       cpp.scale(.45)
#       cpp.shift(ORIGIN)
#       self.play(Create(cpp))
#       self.play(cpp.animate.to_edge(UP), run_time=3)
#       self.play(cpp.animate.to_edge(RIGHT), run_time=3)
#       st=Text("Old Coordinate: x, y", font_size=20)
#       st.shift(UP*2, LEFT*3)
#       self.play(Write(st))
#       st2=Text("New Coordinate: x', y'", font_size=20)
#       st2.shift(UP*1, LEFT*3)
#       self.play(Write(st2))
#       st3=Text("In That Case:\nx'= Scaling * x y'=Scaling * y", font_size=20)
#       box3 = SurroundingRectangle(st3, color=YELLOW, buff=MED_LARGE_BUFF)
#       group3=VGroup(box3,st3)
#       group3.shift(np.array([-3,-1,0]))
#       self.play(Create(group3), run_time=4)
#       self.wait(2)
#       self.remove(st,st2)
#       self.wait(2)
#       self.play(group3.animate.to_edge(UP))
#       var = 0.5
#       on_screen_var = Variable(var, Text("Scale X"), num_decimal_places=3)
# 
#       # You can also change the colours for the label and value
#       on_screen_var.label.set_color(RED)
#       on_screen_var.value.set_color(GREEN)
#       on_screen_var.scale(.75)
#       on_screen_var.shift(np.array([-1,-1,0]))
# 
#       self.play(Write(on_screen_var))
#       # The above line will just display the variable with
#       # its initial value on the screen. If you also wish to
#       # update it, you can do so by accessing the `tracker` attribute
#       self.wait()
#       var_tracker1 = on_screen_var.tracker
#       var = 5
#       #self.play(var_tracker1.animate.set_value(var))
#       self.wait()
# 
#       int_var = .5
#       on_screen_int_var = Variable(
#           int_var, Text("Scale Y"), num_decimal_places=3
#       ).next_to(on_screen_var, DOWN)
#       on_screen_int_var.label.set_color(RED)
#       on_screen_int_var.value.set_color(GREEN)
#       on_screen_int_var.scale(.75)
#       on_screen_int_var.shift(np.array([0,-.25,0]))
# 
#       self.play(Write(on_screen_int_var))
#       self.wait(2)
#       var_tracker = on_screen_int_var.tracker
#       var = 5
#       cpp.shift(LEFT*1, DOWN*1)
#       self.wait(2)
#       self.play(var_tracker.animate.set_value(var),var_tracker1.animate.set_value(var), cpp.animate.scale(2))
#       self.wait(3)
#       self.remove(on_screen_int_var,on_screen_var)
#       self.wait(2)
#       text5=Text("Matrix Representation: ", font_size=25)
#       text5.shift(np.array([-2,.5,0]))
#       self.play(Write(text5))
#       self.wait(2)
#       m0 = Matrix([['X'], ['Y']])
#       m1 = Matrix([['x'], ['y']])
#       m2 = Matrix([['Sx', 0], [0, 'Sy']])
# 
#       matrixg = Group(
#             m1,m2
#         ).arrange_in_grid(buff=0.5)
#       matrixg.shift(np.array([-2,-1,0]))
#       matrixg.scale(.75)
#       m0.scale(.75)
#       m0.shift(np.array([0.5,-1,0]))
#       self.add(matrixg)
#       self.wait(2)
#       self.add(m0)
#       text6=Text("Multiplying the first two matrix will result into the\nthird matrix which is your resultant!", font_size=20, color=BLUE)
#       box6 = SurroundingRectangle(text6, color=YELLOW, buff=MED_LARGE_BUFF)
#       gpx=VGroup(box6,text6)
#       gpx.shift(np.array([-2,-3,0]))
#       self.play(Write(gpx), run_time=4)
# 
# 
# 
#     
# 
# 
# 
#       self.wait(3)
#

